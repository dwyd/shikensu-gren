{"Shikensu":{"name":"Shikensu","comment":"\n\n# 🚀\n\n@docs program, programs, Program, Task, list, perform\n\n\n# IO\n\n@docs read, write\n\n\n# 🛠️\n\n@docs bundle\n\n","unions":[],"aliases":[{"name":"Program","comment":" Alias for a Node program.\n","args":[],"type":"Node.Program {} {}"},{"name":"Task","comment":" Alias for the main `Task` type we'll be working with here.\n","args":[],"type":"Task.Task Shikensu.Error.Error Shikensu.Bundle.Bundle"}],"values":[{"name":"bundle","comment":" A `Task` that bundles an array of definitions (compendium).\n\nUse this to write a custom array of definitions to disk\n(there's an example in the `perform` function docs).\n\n","type":"FileSystem.Permission -> Array.Array Shikensu.Definition.Definition -> Shikensu.Bundle.Bundle"},{"name":"list","comment":" The `list` function itself, unwrapped.\n\nRecursively lists a directory and then gives you a `Task`\ncontaining a `Bundle` which in turns has an array of `Definition`s\nstored under the property named `compendium`.\n\nThis collection of `Definition`s is the main thing you'll be working with.\nThe goal of this library is to scan a file tree, manipulate it and then\noptionally write it back to disk. This is done through these definitions.\n\n    import FileSystem.Path as Path\n    import Shikensu\n\n    Shikensu.perform\n        -- To ignore, return `Cmd.none`\n        { onSuccess = \\env _ -> Stream.sendLine env.stdout \"🧪 Sequence completed\"\n        , onError = \\env err -> Stream.sendLine env.stderr (\"🚨 \" ++ Error.toString err)\n        }\n        (\\fsPermission ->\n            Path.empty\n                |> Shikensu.list fsPermission\n                |> Task.map (Shikensu.withExtension \"md\")\n        )\n\n","type":"FileSystem.Permission -> FileSystem.Path.Path -> Shikensu.Task"},{"name":"perform","comment":" A utility function that helps you create programs.\n\nThis function is also useful for when you want to write definitions to disk.\nMaybe you have a JSON file and you want to split it up in multiple files,\nthat's something you can do with this function.\n\n    import FileSystem.Path as Path\n    import Shikensu\n\n    Shikensu.perform\n        -- To ignore, return `Cmd.none`\n        { onSuccess = \\env _ -> Stream.sendLine env.stdout \"🧪 Sequence completed\"\n        , onError = \\env err -> Stream.sendLine env.stderr (\"🚨 \" ++ Error.toString err)\n        }\n        (\\fsPermission ->\n            [ { baseName = \"json-file-1\"\n              , content = Just jsonBytes\n              , directoryPath = Path.fromPosixString \"splitted\"\n              , extensionName = Just \"json\"\n              , metadata = Dict.empty\n              }\n            ]\n                |> Shikensu.bundle fsPermission\n                |> Task.andThen (Shikensu.write CurrentDirectory)\n        )\n\nThis uses `Node.defineSimpleProgram` and `FileSystem.initialize` underneath\nand then manages the `Shikensu.Task` value created by `list` or some other function.\n\nSee the `list` function above for an example using `list`.\n\n","type":"{ onSuccess : Node.Environment -> a -> Task.Task Shikensu.Error.Error {}, onError : Node.Environment -> Shikensu.Error.Error -> Task.Task Basics.Never {} } -> (FileSystem.Permission -> Task.Task Shikensu.Error.Error a) -> Shikensu.Program"},{"name":"program","comment":" Create a Shikensu Program.\n\nThis is basically a wrapper around `list` and `perform`.\nIt creates a `SimpleProgram` for you, initialises the needed permissions,\nlists the given directory path, and finally performs the given task (sequence).\nIt also prints errors to stderr or a success message to stdout.\n\nThe example below with the comments should help you understand the flow:\n\n    import FileSystem.Path as Path\n    import Shikensu\n    import Shikensu.Contrib as Shikensu\n    import Task\n\n    -- Our `Program` which references our `sequence` (more on that later)\n    -- and our relative directory path we want to list (empty path = current directory)\n    main =\n        Shikensu.program sequence Path.empty\n\n    -- This is our `sequence`.\n    -- Here we receive a `Task` that contains the directory listing (aka. the compendium)\n    -- We essentially do two things with this listing:\n    -- (1) We manipulate it (these are the `Task.map` calls)\n    -- (2) Or we perform some IO operation (these are the `Task.andThen` calls)\n           -> `read` reads the content of the files.\n           -> `write` writes the manipulated in-memory representations of the files back to disk.\n    sequence task =\n        task\n            |> Task.map (Shikensu.withExtension \"md\")\n            |> Task.andThen Shikensu.read\n            |> Task.map (Shikensu.renderContent markdownRenderer) -- See `example` folder\n            |> Task.andThen (Shikensu.write destinationPath)\n\n","type":"(Shikensu.Task -> Shikensu.Task) -> FileSystem.Path.Path -> Shikensu.Program"},{"name":"programs","comment":" Provides a way to make multiple lists and operate on them.\n\nTechnically not multiple programs, but same idea as\nthe `program` function, just with multiple lists.\n\nPrograms are performed sequentially.\n\n    import FileSystem.Path as Path\n    import Shikensu\n\n    Shikensu.programs\n        [ { path = Path.fromPosixString \"./posts\"\n          , sequence = Task.andThen Shikensu.read\n          }\n        , { path = Path.fromPosixString \"./images\"\n          , sequence = Task.map (\\bundle -> ...)\n          }\n        ]\n\n","type":"Array.Array { path : FileSystem.Path.Path, sequence : Shikensu.Task -> Shikensu.Task } -> Shikensu.Program"},{"name":"read","comment":" Read the files in the given compendium/bundle,\nsetting the `content` property in the definition.\n","type":"Shikensu.Bundle.Bundle -> Shikensu.Task"},{"name":"write","comment":" Write each definition to their respective location.\nThe location will depend on the destination path.\n","type":"FileSystem.Path.Path -> Shikensu.Bundle.Bundle -> Shikensu.Task"}],"binops":[]},"Shikensu.Bundle":{"name":"Shikensu.Bundle","comment":"\n\n# Bundle\n\n@docs Bundle, mapCompendium\n\n","unions":[],"aliases":[{"name":"Bundle","comment":" The bundle which is the value of the `Shikensu.Task` type.\n\nMost important part here is the `compendium`, the list of definitions.\nThe rest is contextual information.\n\n","args":[],"type":"{ compendium : Array.Array Shikensu.Definition.Definition, fsPermission : FileSystem.Permission, readingDirectory : Maybe.Maybe FileSystem.Path.Path }"}],"values":[{"name":"mapCompendium","comment":" Convenience function to map over array of `Definition`s.\n","type":"(Array.Array Shikensu.Definition.Definition -> Array.Array Shikensu.Definition.Definition) -> Shikensu.Bundle.Bundle -> Shikensu.Bundle.Bundle"}],"binops":[]},"Shikensu.Contrib":{"name":"Shikensu.Contrib","comment":"\n\nPremade functions to manipulate your bundles/definitions with.\n\n\n# Contrib\n\n@docs clearMetadata, clone, enclose, exclude, insertMetadata, permalink, rename, renameExtension, renderContent, replaceMetadata, setContent, transformContent, withBaseName, withDirectory, withExtension, withMetadata\n\n","unions":[],"aliases":[],"values":[{"name":"clearMetadata","comment":" Clear metadata.\n","type":"Shikensu.Bundle.Bundle -> Shikensu.Bundle.Bundle"},{"name":"clone","comment":" Clone.\n\nFor each definition that has the given `relativePath` (1st argument),\nmake a clone with a new `relativePath` (2nd argument),\nand add that into the compendium just after the matching definition.\n\n    >>> clone \"index.html\" \"200.html\" bundle\n\n","type":"FileSystem.Path.Path -> FileSystem.Path.Path -> Shikensu.Bundle.Bundle -> Shikensu.Bundle.Bundle"},{"name":"enclose","comment":" Append the given directory path to the directory path of each definition.\n","type":"String.String -> Shikensu.Bundle.Bundle -> Shikensu.Bundle.Bundle"},{"name":"exclude","comment":" Exclude.\n\nFilter out the definitions that have the given `path`.\n\n","type":"FileSystem.Path.Path -> Shikensu.Bundle.Bundle -> Shikensu.Bundle.Bundle"},{"name":"insertMetadata","comment":" Insert additional metadata.\n","type":"Dict.Dict String.String Json.Encode.Value -> Shikensu.Bundle.Bundle -> Shikensu.Bundle.Bundle"},{"name":"permalink","comment":" Permalink.\n\nAppend the baseName to the directoryPath\nand change the baseName to the given string.\nIt will NOT change definitions that already have the new baseName.\n\n    >>> permalink \"index\" compendium\n\n","type":"String.String -> Shikensu.Bundle.Bundle -> Shikensu.Bundle.Bundle"},{"name":"rename","comment":" Rename.\n\nChange the `relativePath` of the definitions that match a given `relativePath`.\nFor example, if you have a definition with the relativePath path `a/b/example.html`:\n\n    >>> rename\n    ..>   (Path.file [ \"a\", \"b\", \"example.html\" ])\n    ..>   (Path.file [ \"example\", \"index.html\" ])\n    ..>   compendium\n\n","type":"FileSystem.Path.Path -> FileSystem.Path.Path -> Shikensu.Bundle.Bundle -> Shikensu.Bundle.Bundle"},{"name":"renameExtension","comment":" Rename extension.\n\nExample:\n\n    >>> renameExtension \"markdown\" \"html\" compendium\n    ..> -- The definitions that had the extensionName \"markdown\"\n    ..> -- now have the extensionName \"html\"\n\n","type":"String.String -> String.String -> Shikensu.Bundle.Bundle -> Shikensu.Bundle.Bundle"},{"name":"renderContent","comment":" Render content.\n\nReplace the `content` property by providing a renderer.\nA renderer is a function with the signature `Definition -> Maybe Bytes`.\nYou can use this to render templates, markdown, etc.\n\n","type":"(Shikensu.Definition.Definition -> Maybe.Maybe Bytes.Bytes) -> Shikensu.Bundle.Bundle -> Shikensu.Bundle.Bundle"},{"name":"replaceMetadata","comment":" Replace metadata.\n\nReplace the current metadata dictionary with another one.\n\n","type":"Dict.Dict String.String Json.Encode.Value -> Shikensu.Bundle.Bundle -> Shikensu.Bundle.Bundle"},{"name":"setContent","comment":" Set content.\n\nSet content directly.\n\n","type":"Bytes.Bytes -> Shikensu.Bundle.Bundle -> Shikensu.Bundle.Bundle"},{"name":"transformContent","comment":" Transform content.\n\nAlias for `renderContent`.\n\n","type":"(Shikensu.Definition.Definition -> Maybe.Maybe Bytes.Bytes) -> Shikensu.Bundle.Bundle -> Shikensu.Bundle.Bundle"},{"name":"withBaseName","comment":" Only keep definitions with the given base name.\n","type":"String.String -> Shikensu.Bundle.Bundle -> Shikensu.Bundle.Bundle"},{"name":"withDirectory","comment":" Only keep definitions with the given directory path.\n","type":"FileSystem.Path.Path -> Shikensu.Bundle.Bundle -> Shikensu.Bundle.Bundle"},{"name":"withExtension","comment":" Only keep definitions with the given extension.\n","type":"String.String -> Shikensu.Bundle.Bundle -> Shikensu.Bundle.Bundle"},{"name":"withMetadata","comment":" Only keep definitions with the given metadata.\n","type":"String.String -> Json.Encode.Value -> Shikensu.Bundle.Bundle -> Shikensu.Bundle.Bundle"}],"binops":[]},"Shikensu.Definition":{"name":"Shikensu.Definition","comment":"\n\n# Definition\n\n@docs Definition, create, fork\n\n","unions":[],"aliases":[{"name":"Definition","comment":" **A piece of content.**\n\nExample definition, given:\nThe working directory root path `/Users/icidasset/Projects/shikensu/example/`\nand the full item path `/Users/icidasset/Projects/shikensu/example/test/hello.md`\n\n    { content = Nothing\n    , path = FileSystem.Path.fromPosixString \"test/hello.md\"\n    , metadata = Dict.empty\n    }\n\n","args":[],"type":"{ content : Maybe.Maybe Bytes.Bytes, path : FileSystem.Path.Path, metadata : Dict.Dict String.String Json.Encode.Value }"}],"values":[{"name":"create","comment":" Create a definition, given a (relative) path.\nIn other words, the `root` property of a given path will always be ignored.\n","type":"FileSystem.Path.Path -> Shikensu.Definition.Definition"},{"name":"fork","comment":" Fork a definition, given a relative path.\nTaking the metadata and content of the original definition.\n","type":"FileSystem.Path.Path -> Shikensu.Definition.Definition -> Shikensu.Definition.Definition"}],"binops":[]},"Shikensu.Error":{"name":"Shikensu.Error","comment":"\n\n# Error\n\n@docs Error, toString\n\n","unions":[{"name":"Error","comment":"","args":[],"cases":[["ErrorMessage",["String.String"]],["PlatformError",["FileSystem.Path.Path","FileSystem.Error"]]]}],"aliases":[],"values":[{"name":"toString","comment":"","type":"Shikensu.Error.Error -> String.String"}],"binops":[]}}