module Shikensu exposing ( Program, Task, list, program, read, write )

{-|


# 🚀

@docs program, Program, list, Task, Error


# IO

@docs read, write



-}

import Bytes.Encode
import FileSystem
import Node.Program as Node
import Shikensu.Bundle as Bundle exposing ( Bundle )
import Shikensu.Definition as Definition exposing ( Compendium, Definition )
import Shikensu.Error exposing ( Error(..) )
import Shikensu.Focus as Focus exposing ( Focus(..) )
import Shikensu.Path as Path exposing ( Path, Kind(..), Encapsulated, Directory, File )
import Task



-- 🧩


{-|-}
type alias Program =
    Node.Program {} {}


{-| Simple alias for working with tasks dealing with bundles.
-}
type alias Task =
    Task.Task Error Bundle



-- 🚀


{-| Create a Shikensu Program.

This is basically a wrapper around `list` that creates a Program
for you and initialises the needed permissions.

-}
program : (Task -> Task) -> Focus -> Program
program taskFn focus =
    (\fsPermission ->
        focus
            |> list fsPermission
            |> taskFn
            |> Task.attempt (\_ -> {})
            |> Node.endWithCmd
    )
        |> Node.await FileSystem.initialize
        |> Node.defineSimple


{-| Recursively list a directory.
-}
list : FileSystem.Permission -> Focus -> Task
list fsPermission focus =
    fsPermission
        |> Path.currentWorkingDirectory
        |> Task.mapError neverError
        |> Task.andThen
                (\cwd ->
                    let
                        focusDirectory =
                            Focus.toAbsolutePath
                                { cwd = cwd
                                }
                                focus
                    in
                    []
                        |> Path.directory
                        |> recursiveList fsPermission focusDirectory
                        |> Task.map
                                (\compendium ->
                                    { compendium = compendium
                                    , focusDirectory = focusDirectory
                                    , fsPermission = fsPermission
                                    , workingDirectory = cwd
                                    }
                                )
                )



-- IO


{-| Read the files in the given compendium/bundle,
setting the `content` property in the definition.
-}
read : Bundle -> Task
read bundle =
    bundle.compendium
        |> Array.map
                (\def ->
                    def
                        |> Definition.relativePath
                        |> Path.combine bundle.focusDirectory
                        |> (\path ->
                                path
                                    |> Path.toPosix
                                            { absolute = True
                                            }
                                    |> FileSystem.openForRead bundle.fsPermission
                                    |> Task.mapError (PlatformAccessError (Path.encapsulate path))
                            )
                        |> Task.andThen
                                (\handle ->
                                    handle
                                        |> FileSystem.read
                                        |> Task.mapError PlatformUnknownError
                                        |> Task.map (\bytes -> { def | content = Just bytes })
                                        |> Task.andThen
                                                (\updatedDef ->
                                                    handle
                                                        |> FileSystem.close
                                                        |> Task.map (\_ -> updatedDef)
                                                        |> Task.mapError PlatformUnknownError
                                                )
                                )
                )
        |> Task.sequence
        |> Task.map (\compendium -> { bundle | compendium = compendium })


{-| Write each definition to their respective location.
-}
write : Focus -> Bundle -> Task
write destinationFocus bundle =
    destinationFocus
        |> Focus.toAbsolutePath
                { cwd = bundle.workingDirectory
                }
        |> (\destinationDirectory ->
                bundle.compendium
                    |> Array.map (writeDef bundle.fsPermission destinationDirectory)
                    |> Task.sequence
                    |> Task.map (\_ -> bundle)
            )


writeDef : FileSystem.Permission -> Path Directory -> Definition -> Task.Task Error {}
writeDef permission destinationDirectory def =
    def
        |> Definition.relativePath
        |> Path.combine destinationDirectory
        |> (\path ->
                path
                    |> Path.toPosix
                            { absolute = True
                            }
                    |> FileSystem.openForWrite permission FileSystem.EnsureEmpty
                    |> Task.mapError (PlatformAccessError (Path.encapsulate path))
            )
        |> Task.andThen
                (\handle ->
                    def.content
                        |> Maybe.withDefault
                                (Bytes.Encode.encode
                                    <| Bytes.Encode.string ""
                                )
                        |> FileSystem.write handle
                        |> Task.mapError PlatformUnknownError
                )
        |> Task.map (\_ -> {})
        |> Task.onError
                (\err ->
                    case err of
                        PlatformAccessError path FileSystem.AccessErrorNotFound ->
                            -- Make sure directory tree exists
                            let
                                directoryPath =
                                    path
                                        |> Path.unwrap
                                        |> Array.dropLast 1
                                        |> Path.directory

                                directoryPathString =
                                    Path.toPosix
                                        { absolute = True
                                        }
                                        directoryPath
                            in
                            { recursive = True
                            }
                                |> FileSystem.makeDirectory permission directoryPathString
                                |> Task.mapError (PlatformAccessError (Path.encapsulate directoryPath))
                                |> Task.andThen (\_ -> writeDef permission destinationDirectory def)

                        _ ->
                            Task.fail err
                )



-- ㊙️


neverError : Never -> Error
neverError _ =
    PlatformUnknownError (FileSystem.UnknownFileSystemError "Never ever have I 🤫")


recursiveList : FileSystem.Permission -> Path Directory -> Path Directory -> Task.Task Error Compendium
recursiveList permission focusDirectory relativePath =
    relativePath
        |> Path.combine focusDirectory
        |> (\path ->
                path
                    |> Path.toPosix
                            { absolute = True
                            }
                    |> FileSystem.listDirectory permission
                    |> Task.mapError (PlatformAccessError (Path.encapsulate path))
            )
        |> Task.andThen
                (\listing ->
                    listing
                        |> Array.filterMap
                                (\entry ->
                                    -- TODO: Add option to also list hidden files
                                    case entry of
                                        FileSystem.File name ->
                                            if String.startsWith "." name then
                                                Nothing
                                            else
                                                name
                                                    |> Array.singleton
                                                    |> Path.file
                                                    |> Path.combine relativePath
                                                    |> Definition.create
                                                    |> Array.singleton
                                                    |> Task.succeed
                                                    |> Just

                                        FileSystem.Directory name ->
                                            name
                                                |> Array.singleton
                                                |> Path.directory
                                                |> Path.combine relativePath
                                                |> recursiveList permission focusDirectory
                                                |> Just

                                        _ ->
                                            Nothing
                                )
                        |> Task.sequence
                        |> Task.map Array.flatten
                )
